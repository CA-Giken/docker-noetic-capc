def GET_NORM_VEC(p,axis=2):
  rot=p[0.0, 0.0, 0.0, p[3], p[4], p[5]]
  vec=p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  vec[axis]=1.0
  norm_p=pose_trans(rot,vec)
  return [norm_p[0], norm_p[1], norm_p[2]]
end

def GET_INNER_PRODUCT(v1,v2):
  return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2]
end
def GET_OUTER_PRODUCT(v1,v2):
  x=v1[1]*v2[2]-v1[2]*v2[1]
  y=v1[2]*v2[0]-v1[0]*v2[2]
  z=v1[0]*v2[1]-v1[1]*v2[0]
  return [x,y,z]
end
def GET_THETA(v1,v2):
#  cos=GET_INNER_PRODUCT(v1,v2) / norm(v1) / norm(v2)
  cos=GET_INNER_PRODUCT(v1,v2)
  g_cos=cos
  theta=norm(acos(cos))
  return theta
end

def GET_ALIGNED_POSE(target,feature,axis=2):
  feature_from_target=pose_trans(pose_inv(target),feature)
  g_f_from_t=feature_from_target
  nz_feature_from_target=GET_NORM_VEC(feature_from_target,axis)
  g_nz_f_from_t=nz_feature_from_target
  nz_target_from_target=[0.0, 0.0, 0.0]
  nz_target_from_target[axis]=1.0
  g_nz_t_from_t=nz_target_from_target

  theta=GET_THETA(nz_feature_from_target,nz_target_from_target)
  g_theta=theta
  rot_vec_n=normalize(GET_OUTER_PRODUCT(nz_target_from_target,nz_feature_from_target))

  if theta>d2r(90.0):
    theta=theta-d2r(180.0)
  end
  rot_vec=rot_vec_n * (theta)
  rot_p=p[0.0,0.0,0.0,rot_vec[0],rot_vec[1],rot_vec[2]]
  return pose_trans(target,rot_p) 
end
def GET_ALIGNED_TCP(feature,axis=2):
  tcp=get_actual_tcp_pose()
  return GET_ALIGNED_POSE(tcp,feature,axis)
end

